# js基础题

标签（空格分隔）： 面试题

---
[toc]
## 隐式转换
1.运算符（+符号比较特殊）

    1 + '2' = 12
    1 + 2 + '3' = 33

2.if，for-in，while条件循环语句

    if(1){} //会转换为boolean值

3.valueof（）和tostring（），number（）

## 将字符串转换为数值的方法
Number（），parseInt（），值运算

## null和undefined的区别
null：是设置了一个对象并赋值了，只是这个值是空的
undefined：是设置了但没赋值

## 节点操作
### nodetype类型
1.nodetype == 1   元素节点
2.nodetype == 2   属性节点
3.nodetype == 3   文本节点

### 添加节点
appendChild()  在childNodes列表末尾添加节点
insertBefore() 在childNodes列表指定位置添加节点
replaceChild() 替换列表中的某节点
替换的新节点是document创建的，不是var声明的
removeChild()  移出列表中的某节点

### Document类型
firstChild  ==  childNodes[0]
三个与网页有关的属性：
1.URL：包含完整的url
2.domain：包含页面的域名
3.referrer： 保存着链接到当前页面的那个页面的URL

### 查找元素
1.getElementById()
2.getElementByTagName()
3.getElementByClassName()

### 属性
1.getAttribute()      获取属性
2.setAttribute()      设置属性
3.removeAttribute()   移出属性  


### 创建
1.createElement()     创建元素
2.createTextNode()    创建文本节点
document.createElement();document.createTextNode()这样调用

## 数组
### 创建一个数组的方法
1.new Array（）实例对象
可以传入数组长度new Array（5）
可以复制new Array([1,2,3])
返回的数组长度为1，就是创建了一个数组，数组里面只有一项，这一项也是数组，就是二维数组
2.创建表达式
var arr1 = []
可以直接复制var arr1 = [1,2,3]

### 数组的内置方法们
1.length（）  返回数组长度
2.push（） 从数组尾部添加
3.unshift（） 从数组头部添加
4.pop() 从数组尾部删除
5.shift（） 从数组头部删除
6.concat（） 合并两个数组
7.join（） 把当前数组用指定字符串连接起来，并返回的字符串
8.slice（） 截取数组部分长度，并返回新数组
9.splice（） 在指定位置添加/删除指定位数的数组项，返回新数组
10.indexof（） 返回指定数组项的位置索引，没有返回-1
11.sort（） 将数组重新排序后，返回新数组
12.reverse（） 将数组倒序后返回新数组

### 数组去重
1.基本数组去重

    array.prototype.unique = function(){
    	var result = [];
    	this.foreach(function(v){
    		if(result.indexof(v) < 0) {
    			result.push(v)
    		}
    		return result
    	})
    }

2.先排序在去重

    array.prototype.unique = function(){
    	var result = [];
    	this.foreach(function(v){
    		if(result.indexof(v) < 0) {
    			result.push(v)
    		}
    		return result
    	})
    }
    
### 数组的删除
有两种方法删除，第一种用delete方法，delete arr[0]，这种方法知识将arr[0]这一项变味了undefined，数组的长度是不变的
另一种方法就是splice方法，这个方法接收至少两个参数，第一个参数表示从第几位开始删除（索引值），第二个参数表示要删除多少项，假如要清空数组，就可以将第二个参数设为arr.length

## 合并对象
1.jQuery.extend([deep], target, object1, [objectN])

> $.extend({},obj1,obj2) //此时obj1没被修改，obj3 !== obj1 $.extend(obj1,obj2)
> //此时obj1已被修改 obj4 = obj1

2.用 Object.assign()

> Object.assign(obj1,obj2) //此时obj1本身也被改变

3.遍历赋值法 

    var extend = function(o,n){
        for(p in n){
           if (n.hasOwnProperty(p) && (!o.hasOwnProperty(p) )){
              o[p] = n[p]
           }
        }
    }
4.展开符

    let arr = ['b','c']
    ['a',...arr,'d']
    //['a','b','c','d']

## map 和 foreach的区别
map是根据函数执行后返回一个新数组，foreach是没有返回值的，所以没有办法终止或跳出循环的

## 遍历一个对象的方法
1.迭代遍历foreach
2.ES6之6种遍历对象属性的方法：for in 、 Obejct.keys(obj) 、 Object.getOwnPropertyNames(obj) 、 Object.getOwnPropertySymbols(obj) 、 Reflect.ownKeys(obj) 、 Reflect.enumerate(obj)
3.jquery方法each

## 缓存机制
http的响应头中有一个叫Expires的字段，告诉浏览器一个过期时间，在过期时间前，浏览器可以直接读取缓存不需要再次请求。但是这是一个老东西了现在基本不用了。
代替expires的是cache-control，也是指明资源的有效期来判断是否发起新的请求，好像比expires要高级一点具体的我不太清楚。
然后如果资源到期了，就要判断Last-Modified资源最后修改的时间，如果过期且有最后修改的时间，则向服务器发送If-Modified-Since带着最后修改时间与服务器上的资源的最后修改时间进行比对，如果资源有修改返回200，把新资源发送给浏览器，如果没有修改则返回304读取缓存就好。
然后还有一种ETag的方式，也是最准确的
etag是将文件的索引（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到。
 如果过期了将etag发送给服务器，与服务器上的资源的校验串进行比对，决定是200还是304.
etag解决了可以比Last-Modified更精确，精确到了毫秒级。
如果文件被定期生成但是内容却没有任何变化Last-Modified也不能正确判断

## js的几种数据类型
number boolean object undefined string null

## js的几种引用类型
函数，对象，数组

## js的几种内置对象
number string Function Array Object Boolean Date Math Regexp

## js的同步和异步
个人总结：由于js的主要用途是与用户交互以及操作Dom树，所以他只能是单线程的，所谓同步就是把任务放在主线程上，一次执行，只有执行完上一个任务才能执行下一个任务，而异步就是不进入主线程的任务，而进入任务队列中，在主线程的任务都结束了，之后，在来执行队列中的人物

## 标签语义化的理解
根据内容结构化选择合适的标签便于开发者阅读和浏览器爬虫爬去数据
好处是： 
1.可以在css加载失败时，页面也能呈现出良好的效果
2.在团队开发中，语义化标签有利于课增强可读性
3.便于搜索引擎，爬虫是根据标签确定还是那个下文的
4.方便其他设备解析代码
html5新增的语义化标签：header，footer,nav,articl,section,asied
注意点：
1.input标签对应的说明文本要用label标签，
2.使用表格时，标题用caption，表头用tHead，主体用tBody

## js事件流
定义：事件流就是接收时间的顺序（个人理解：事件发生的流水线）
事件流分为三个阶段：
事件捕获阶段：从最外层父元素开始，一次向下执行事件
目标阶段：找到最内层的目标对象
事件冒泡事件：从最具体的元素开始执行，一次向上执行

## TCP的三次握手和四次挥手
三次握手：
1.客户端发送一个SYN的请求，告诉服务端我想链接你
2.服务端收到请求，回答一个ACK，并告诉客户端我已经准备好了SYN
3.客户端收到回复后，回答一个ACK给服务端
于是便可进行数据请求了
四次挥手：
1.客户端发送一个FIN给服务端，告诉他我想断开了
2.服务端回答一个ACK说知道了，但我还有没完的数据要传给你
3.服务端将数据传递完以后，发送FIN告知客户端
4.客户端给了一个ACK的回应，say拜拜


## 输入一个url以后 会发生什么（请求数据过程）
第一步：DNS域名解析（缓存->操作系统->获取ip地址）
第二步：建立TCP连接：三次握手
第三步：发送http请求（报文头，主体，方式）
第四步：响应http请求（响应头，主体）
第五步：渲染页面（构建DOM树，css树，整合成RenderTree渲染树）

第一步涉及到缓存机制：
第五步涉及到性能优化：

## mvc & mvp & mvvm
1. mvc的全称是model view controlltor  ， 他们之间的关系就是view层通知controlltor用户需要改变，controlltor收到通知后通知model层做一些数据处理，最后model层将数据返回给view层，他的缺点是model层和view层没有解耦，在大型项目中会很麻烦
2. mvp 的全称是view model presenter  他们之间的关系是view层发出指令要改变，prsenter层接收到指令后，去操作model层，操作好以后将最终数据返回给view层  他的好处是view层和model层完全解耦，而且view层和presenter层可以通过相关接口连接
3. mvvm 的全称是view model viewmodel  他们之间的关系是view层和viewmodel层双向绑定，也就是他们两者之间任何一个改变，都会影响另一方改变，同样也是viewmodel层通知model层进行数据处理，model层将处理好的数据返回给viewmodel层，进而使view层发生改变


##  八大排序
插入排序
### 直接插入排序
基本思想：选择序列的第一项看作一个有序子序列，从第二个序列项开始逐个插入，直到整个序列变为有序序列
### 希尔排序
基本思想：将整个序列分为若干个子序列，在子序列中进行中直接插入排序，“基本有序”后再将整个序列进行直接插入排序，希尔排序相较于直接插入排序的优点是，节约的时间
方法：假设有n个序列项， 设相聚d=n/2的两项为一组，这样将整个序列分为d个子序列，将子序列进行直接排序，再取d=d/2，一次进行直接排序，直到整个序列有序
交换排序
### 冒泡排序
基本思想：从第一个序列项开始，一次与相邻项比较，反序则交换。这样让较小的项网上冒，较大的项往下沉
### 快速排序
基本思想：选择一个基准序列项，一般为第一个或者最后一个，然后将待排序列项分为两部分，左边为小于基准项的区域，右边为大于基准项的区域，重复上述步骤，直到有序
选择排序
### 简单选择排序
基本思想：以第一序列项为基准，选择其余序列项中最小的项与第一项交换位置，再以第二个序列项为准，选择其余项的最小项进行交换，重复进行，直到有序

### 堆排序
基本思想：将序列构造成一个堆，序列中最大项为堆顶，去除最大项，将剩余的项选出最大项，构成堆，重复操作，直到有序

## 事件委托（事件代理）
个人理解总结：事件代理就是，利用事件冒泡机制，把事件委托到父元素上，使一个页面只触发一个事件函数，从而减少对Dom树的操作，实现性能优化
要点：event有一个target对象，可以返回事件的目标节点（标准浏览器是ev.target,IE浏览器是event.srcEvent），如果要获取目标节点的名称，可以用nodeName

## HTTP八大请求
1.option:用于返回指定资源所支持的http请求方式，当你向测试服务器的性能的话，可以用*代替指定资源，用来查看服务器的性能；
2.get：是最常见的请求方式之一，用来获取请求资源，他的缺点就是get的请求是携带在url地址里的，所以他不安全
3.post:也是做常见的请求方式之一，用于提交资源，他克服了get的缺点，因为它是将请求放在请求本文中，所以他叫安全
4.put：就是向指定资源位置上放入新的内容
5.delete：删除指定资源位置的内容
6.head：它是用于所要与get请求一致的相应，但他只会返回头部，
7.trace：它是用来回显服务器接收的请求，可以在测试或者诊断的时候用
8.connect：预留给将链接转换为管道方式的代理服务器，他通常用于ssl加密服务器连接

### get & post的差别
1.get是将请求携带在url里的，所以不安全，但post是将请求放在请求体内的，所以较安全
2.get请求有大小限制，最多1024个字节，而post无限大

## 状态码
状态码有五大类，分别以数字1-5开头
第一种1开头的，不常见，属于客户方错误，比如101  交换协议
第二种2开头的，表示成功，最常见的有200，表示请求成功，其他还有204 无内容，206 部分内容  202 接收内容
第三种3开头的，主要表示重定向，最常见的就是304 无改变，比如说缓存机制里边，当向服务器发送带有最后修改时间的If-Modified-Since时，会与服务器最后的修改时间作比较，其中一种情况就是304.表示没有改变，直接在缓存中取
第四种4开头的，属于客户方错误，最常见就是404 找不到信息，另外还有400 错误请求  403 禁止访问
第五种5开头的，属于服务器错误，最常见就是500 服务器内部错误


## dom0 & dom2 的区别
1.dom0的click时间是写在html标签里的或者js的var click= function
dom2的click事件是addEventListen或者removeEvrnyListenr，接收三个参数，第一个是事件类型，第二个是定义的执行函数，第三个是boolean值，false表示事件冒泡，true表示事件捕获；
2.dom0是会被覆盖的，而dom2不会被覆盖

## Express框架
框架核心：中间件，路由器，模板引擎（jade，ejs）
1.中间件：处理http请求的函数，她接受三个参数：request（req），respone（res），next（）回掉函数。
2.路由器：框架可以配置路由，可以配置根路径或者指定特定的路径，它拥有get和post方法，接收两个参数：路径和回调函数
3.模板引擎：node的模板引擎一般有两种：jade和ejs。要设置模板引擎就调用set方法，调用模板引擎就调用rander方法

## 居中问题
个人将他分为定宽与不定宽
1.不定宽：
第一种：针对内联元素或者属性为inline-block的元素，需要设置他的父元素
text-algin和verticle-algin都为center就可以了
第二种：利用绝对定位实现，让他的父元素为相对定位，子元素为绝对定位，设置他们的left和top都为50%，在利用transform：translate（-50%，-50%），将他们拉回中间位置
第三种：利用弹性布局。设置父元素为flex属性，将他的justify-content和algin-item设置为center

2.定宽：
主要是针对水平居中，对于定宽div居中，设置他的margin：0 auto

## 关于cookie
第一什么是cookie：他就是保存着客户信息的文本信息，它本身是没有缓存能力的，只是用来实现前后端交互信息的，但他能保存客户信息，所以借用来实现缓存了
第二他的工作原理：cookie是针对于浏览器端的，他能实现缓存，是因为他会跟踪浏览器与服务器的会话，（一次会话就是前后端的链接到关闭，当浏览器关闭时，会话就结束）
第三他的分类：cookie有一个expires参数，表示他的有效期，因此cookie可以分为两种会话cookie和持久cookie。会话cookie就是没有设置有效期，只存在于一次完整的会话中，当浏览器关闭，也就是会话结束之后，他就会被销毁；另一种持久cookie，就是设置了有效期的，他不会随着会话结束销毁，而是在有效期过期之后销毁，就像登陆淘宝页之后，关闭再进入，你依然是登录状态
第四他的参数：cookie还有其他参数，刚刚的expires是一个，还有key 名；value 值；path 路径； domain 域名； secure 安全级别；
第五他的区别：另外cookie和session室友区别的，session是针对服务器端的，就是说服务器端会存储客户信息，而cookie是针对浏览器端的，由浏览器记录用户信息

## 继承
第一种：最完美最常用的继承方式是寄生组合继承，通过在一个立执行函数，将父类的一个实例复制到子类的原型上，再通过构造继承的方式定义子类，这种继承方式规避了组合继承方式生成两次父类实例的问题，但较为复杂
第二种：也很常见的一种方式就是组合继承，它组合了构造继承和原型继承两种方式，所以拥有两者的有点，例如实例既是父类的，也是子类的，不会共享引用属性等
第三种：就是前面提到的原型继承，就是将父类的实例作为子类的原型，但他的缺点在于不能实现多继承，无法想父元素传参等
第四种就是构造继承：计时使用call或者apply方法，把父类的实例复制给子类，他虽然可以实现多继承，但他有无法实现函数复用，不能继承原型属性的缺点
第五种就是实例继承，也就是在子类中给父类的实例添加新特性，这种方式不常用
最后一种是最不推荐的一种，就是拷贝继承，通过遍历父类实例的属性，然后把属性赋给子类的原型，这种很占内存，不推荐

## 浅拷贝 & 深拷贝
浅拷贝就是类似按引用拷贝，就是说改变其中一个对象的属性，同时也会改变另一个对象的属性，像object.assign()就是浅拷贝，它接收两个参数目标对象和任意多个源对象，因为是浅拷贝所以对象之间相互影响
深拷贝就类似于按值拷贝，对象属性之间不会相互影响，常见的深拷贝方法
像上面的object.assign()就可以转换为深拷贝，就是将被拷贝对象作为源对象传入，这样就实现了深拷贝，相互之间不影响
第二种常见就是lodash的.cloneDeep方法，还有jQuery的extend方法
另外还有转换成JSON数据拷贝的，就是将原对象转换成JSON对象，在进行拷贝，但他有一个缺点就是只能拷贝可以转换成JSON对象的对象，想number，string，boolean，array
还有一些红就是递归拷贝，就是遍历源对象的属性，将他赋给新对象
最后一种就是比较麻烦的一种，它也不是真正意义上的深拷贝，就是手动复制，将源对象的属性，手动赋值给新对象，object.assign()就是这个远离实现的

## 为什么选择vue
1.轻量级。有很多便捷的API，所以简单易上手
2.数据驱动，双向数据绑定，模块化，组件化
3.相较于其他框架，vue并不是真正意义上的框架，虽然他跟react，argular框架一样都是组件化的思想，都有双向数据绑定，但因为它只集中于mvvm框架的视图层，他的数据改变并不会像react那样做脏检查
4.但他也有缺点，他没有强大的后备力量，不像argular一样有专门的团队维护

## new操作 具体做了什么工作
1.第一步创建一个空对象
2.第二步设置obj原型链（这一步就确立了作用域）
3.第三步将Func的this指向obj
4.第四步返回创建的对象

## 垃圾回收机制
1.标记清除
就是给进入环境的变量打上进入标记，比如在函数中声明一个变量时，就要打上进入标记，当一个变量不在被调用时，就会打上离开标记。具体操作就是垃圾回收器会给内存中的所有变量打上标记，接着把环境的变量，还有被变量所引用的变量，一般来说就是闭包的情况，把这些变量的标记清除，在这之后如果还有标记的变量证明他们不会在被调用了，就该清除他们了
2.计数清除
就是当一个变量被声明并被赋值时，就给他的引用计数+1，当他的值变为另一个值得时候，他的引用计数就要-1，当一个变量的计数为0时，就说明他要被清楚了
但技术清除有一个问题就是遇到死循环，就是a引用了b，b也引用了a的时候
3.什么时候出发垃圾回收机制，当内存分配量小于程序的15%就清除，大于85%就清除

## 浮动 & 清浮动
1.浮动产生的BUG：由于浮动元素脱离文档流，所以当子元素浮动，而父元素有没有设置宽高的时候，就会产生子元素撑不开父元素的情况
2.清浮动：有三种方法
给浮动元素添加伪类，其实就是添加一个rander DOm节点，设置他的属性为clear：both
添加一个节点，也设置他的属性为clear：both，实现原理与前一种一样
最后一种就是给父元素添加overflow：auto的属性清浮动，实际上是触发了bfc

## BFC
BFC的触发：
1.overflow为hidden，auto，scroll
2.display为table-cell，inline-block
BFC的可以解决外边距重叠的问题也可以解决浮动的问题

## 说说闭包
闭包就是内部函数与外部函数的一座沟通桥梁，有了它外部函数可以访问内部函数的变量，同时外部函数的变量由于被内部函数引用，所以不会被回收
闭包有两种形式，一种是作为参数传入，一种是作为值返回

## 谈谈this
this是在函数调用时确定的，就是在执行上下文确定的时候确定，他指向调用他的对象，在构造函数中的this是指向构造的这个对象的，原型中的this指向原型对象，
call和apply可以指定this指向的对象

## inline-block的间隙问题
水平间隙：
1.给父元素添加font-size为0
2.删除换行，例如使item</li><li>
3.采用注释的方法。把换行编程<--!-->
4.丢置标签不要</li>
5.利用子元素的负外边距
垂直间隙：给子元素添加verticle-algin为bootom


## Z-index可以设置为负数么？设为负数有什么用？
可以，只要一个元素设置为position非static定位，且z-index为负数，那么该元素就会被普通文档流覆盖

## html5 & css3 引入的新特性
1.html5：
用于绘画的canvas
用于媒介回访的video和audio
对本地离线缓存有了提升
增加了一些新标签<header><footer><nav><section><article>,是标签语义化

2.css3
动画效果transform，常用的有定位translate，sclae缩放
border-radius圆角  box-shadow阴影
引入了唯一的伪元素：：selection

## 内存泄漏的问题
1.内存泄漏就是没有用了的内存，却没有被垃圾回收机制回收，就会造成内存泄漏
2.常见的情况有：因为是无法被回收造成的原因所以一切会引起无法进行垃圾回收的方法都会造成内存泄漏，闭包，全局，删除了dom树的节点却没删除节点的事件等等

## 获取URL的参数们
1.第一种简便的方法就是获取url地址后，正则匹配，匹配指定的名值对，并返回
2.第二种是传统的获取参数的的方法用widow.location+参数名获取，例如+search是获取所有参数，+host是获取主机名即ip地址，+path获取文件路径，+port获取端口，+protocol获取协议方式

## 实现文字内容的显示与隐藏
1.display属性，设置为hidden麦科伊隐藏文字
2.visibility属性，默认值visible为可见，hidden为不可见
3.jQuery有一个show（）函数控制内容显示，hide（）函数控制内容隐藏

## SVG & SVG与canvas的区别
1.SVG指可伸缩矢量图形，是基于XML描述的2D图形语言。利用特定的标签实现图形的渲染。
2.因为基于XML，所以他的DOM树是可操作元素，你可以为它添加事件。另外SVG图形都会被视为对象，所以它的变化会引起浏览器页面重绘；因为SVG是可伸缩的矢量图形，所以她适合用来绘制地图，比如百度地图
3.而canvas是标量图形，是一种弱文本渲染能力的语言，所以一旦图形渲染完成，浏览器就不会继续关注，它也支持jpg，png格式的图片，它适合用做游戏开发中，也不支持事件处理

## css预处理器
1.目前流行的预处理器有sass，less，stylus，有了预处理器，可以增强css的一些特性，使开发更简洁方便，易于维护，因为不用考虑兼容性问题，所以适应性更强
2.处理器扩展了css@import，使切分后的文件最后整合到一个总的大文件里面，方便管理，又能解决加载小文件的性能问题；
3.预处理的基本语法是选择符嵌套，这样一来就能清楚的显示层级关系
4.预处理还有变量的概念，就是允许定义一个变量，就是一种简单的抽象方式，例如$color-my:#ffffff,之后白色就代表color-my
5.还有运算的概念，函数的概念，运算就是允许高度，宽度通过运算赋值，函数就是想定义变量一样定义一个函数，将常用的运算抽象出来，再使用，最常见的就是在设置悬停高亮的时候，我们需要打开ps进行去颜色，在赋值，但预处理器draken自动帮你完成这个工作
6.最后还有一个MIxin的实用空能，把一段代码段抽象出来，在需要的地方调用，例如请浮动，将请浮动的代码抽象出来，再在需要的元素上调用

### saas & less的区别
1.执行环境不一样，sass是服务器端处理的，而less是引入lsdd.js文件
2.变量符使用不同。sass是$符号，less是@符号
3.工具库不同，sass的工具库是Compass，他们两者的关系就好比js和jQ的关系，而less的工具库的前端的ui组件库BtoopStrap
4.sass支持条件与，支持引入外部css，支持输出设置（默认为nested嵌套缩进的css），但这些less都不支持。






